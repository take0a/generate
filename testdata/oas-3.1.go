// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "errors"
    "encoding/json"
    "fmt"
    "bytes"
)

// AuthorizationCode 
type AuthorizationCode struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes *MapOfStrings `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// Callbacks 
type Callbacks struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// ClientCredentials 
type ClientCredentials struct {
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes *MapOfStrings `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// Components 
type Components struct {
  Callbacks map[string]interface{} `json:"callbacks,omitempty"`
  Examples map[string]interface{} `json:"examples,omitempty"`
  Headers map[string]interface{} `json:"headers,omitempty"`
  Links map[string]interface{} `json:"links,omitempty"`
  Parameters map[string]interface{} `json:"parameters,omitempty"`
  PathItems map[string]interface{} `json:"pathItems,omitempty"`
  RequestBodies map[string]interface{} `json:"requestBodies,omitempty"`
  Responses map[string]interface{} `json:"responses,omitempty"`
  Schemas map[string]interface{} `json:"schemas,omitempty"`
  SecuritySchemes map[string]interface{} `json:"securitySchemes,omitempty"`
}

// Contact 
type Contact struct {
  Email string `json:"email,omitempty"`
  Name string `json:"name,omitempty"`
  Url string `json:"url,omitempty"`
}

// Content 
type Content struct {
  AdditionalProperties map[string]*MediaType `json:"-,omitempty"`
}

// Encoding 
type Encoding struct {
  AllowReserved bool `json:"allowReserved,omitempty"`
  ContentType string `json:"contentType,omitempty"`
  Explode bool `json:"explode,omitempty"`
  Headers map[string]interface{} `json:"headers,omitempty"`
  Style interface{} `json:"style,omitempty"`
}

// Example 
type Example struct {
  Description string `json:"description,omitempty"`
  ExternalValue string `json:"externalValue,omitempty"`
  Summary string `json:"summary,omitempty"`
  Value interface{} `json:"value,omitempty"`
}

// Examples 
type Examples struct {
  Example interface{} `json:"example,omitempty"`
  Examples map[string]interface{} `json:"examples,omitempty"`
}

// ExternalDocumentation 
type ExternalDocumentation struct {
  Description string `json:"description,omitempty"`
  Url string `json:"url"`
}

// Header 
type Header struct {
  Content *Content `json:"content,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  Required bool `json:"required,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
}

// Implicit 
type Implicit struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes *MapOfStrings `json:"scopes"`
}

// Info 
type Info struct {
  Contact *Contact `json:"contact,omitempty"`
  Description string `json:"description,omitempty"`
  License *License `json:"license,omitempty"`
  Summary string `json:"summary,omitempty"`
  TermsOfService string `json:"termsOfService,omitempty"`
  Title string `json:"title"`
  Version string `json:"version"`
}

// License 
type License struct {
  Identifier string `json:"identifier,omitempty"`
  Name string `json:"name"`
  Url string `json:"url,omitempty"`
}

// Link 
type Link struct {
  Body *Server `json:"body,omitempty"`
  Description string `json:"description,omitempty"`
  OperationId string `json:"operationId,omitempty"`
  OperationRef string `json:"operationRef,omitempty"`
  Parameters *MapOfStrings `json:"parameters,omitempty"`
  RequestBody interface{} `json:"requestBody,omitempty"`
}

// MapOfStrings 
type MapOfStrings struct {
  AdditionalProperties map[string]string `json:"-,omitempty"`
}

// MediaType 
type MediaType struct {
  Encoding map[string]*Encoding `json:"encoding,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
}

// OauthFlows 
type OauthFlows struct {
  AuthorizationCode *AuthorizationCode `json:"authorizationCode,omitempty"`
  ClientCredentials *ClientCredentials `json:"clientCredentials,omitempty"`
  Implicit *Implicit `json:"implicit,omitempty"`
  Password *Password `json:"password,omitempty"`
}

// Operation 
type Operation struct {
  Callbacks map[string]interface{} `json:"callbacks,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  OperationId string `json:"operationId,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`
  RequestBody interface{} `json:"requestBody,omitempty"`
  Responses *Responses `json:"responses,omitempty"`
  Security []*SecurityRequirement `json:"security,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Summary string `json:"summary,omitempty"`
  Tags []string `json:"tags,omitempty"`
}

// Parameter 
type Parameter struct {
  Content *Content `json:"content,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  In interface{} `json:"in"`
  Name string `json:"name"`
  Required bool `json:"required,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
}

// Password 
type Password struct {
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes *MapOfStrings `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// PathItem 
type PathItem struct {
  Delete *Operation `json:"delete,omitempty"`
  Description string `json:"description,omitempty"`
  Get *Operation `json:"get,omitempty"`
  Head *Operation `json:"head,omitempty"`
  Options *Operation `json:"options,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`
  Patch *Operation `json:"patch,omitempty"`
  Post *Operation `json:"post,omitempty"`
  Put *Operation `json:"put,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Summary string `json:"summary,omitempty"`
  Trace *Operation `json:"trace,omitempty"`
}

// Paths 
type Paths struct {
}

// Reference 
type Reference struct {
  Description string `json:"description,omitempty"`
  Ref string `json:"$ref,omitempty"`
  Summary string `json:"summary,omitempty"`
}

// RequestBody 
type RequestBody struct {
  Content *Content `json:"content"`
  Description string `json:"description,omitempty"`
  Required bool `json:"required,omitempty"`
}

// Response 
type Response struct {
  Content *Content `json:"content,omitempty"`
  Description string `json:"description"`
  Headers map[string]interface{} `json:"headers,omitempty"`
  Links map[string]interface{} `json:"links,omitempty"`
}

// Responses 
type Responses struct {
  Default interface{} `json:"default,omitempty"`
}

// Root The description of OpenAPI v3.1.x documents without schema validation, as defined by https://spec.openapis.org/oas/v3.1.0
type Root struct {
  Components *Components `json:"components,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  Info *Info `json:"info"`
  JsonSchemaDialect string `json:"jsonSchemaDialect,omitempty"`
  Openapi string `json:"openapi"`
  Paths *Paths `json:"paths,omitempty"`
  Security []*SecurityRequirement `json:"security,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Tags []*Tag `json:"tags,omitempty"`
  Webhooks map[string]interface{} `json:"webhooks,omitempty"`
}

// Schema_object 
type Schema_object struct {
}

// SecurityRequirement 
type SecurityRequirement struct {
  AdditionalProperties map[string][]string `json:"-,omitempty"`
}

// SecurityScheme 
type SecurityScheme struct {
  Description string `json:"description,omitempty"`
  Type interface{} `json:"type"`
}

// Server 
type Server struct {
  Description string `json:"description,omitempty"`
  Url string `json:"url"`
  Variables map[string]*ServerVariable `json:"variables,omitempty"`
}

// ServerVariable 
type ServerVariable struct {
  Default string `json:"default"`
  Description string `json:"description,omitempty"`
  Enum []string `json:"enum,omitempty"`
}

// Tag 
type Tag struct {
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  Name string `json:"name"`
}

func (strct *AuthorizationCode) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    if strct.Scopes == nil {
        return nil, errors.New("scopes is a required field")
    }
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthorizationCode) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *Callbacks) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Callbacks) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ClientCredentials) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    if strct.Scopes == nil {
        return nil, errors.New("scopes is a required field")
    }
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClientCredentials) UnmarshalJSON(b []byte) error {
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        }
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *Content) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Content) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "*MediaType" value
            var additionalValue *MediaType
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]*MediaType, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ExternalDocumentation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExternalDocumentation) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *Implicit) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    if strct.Scopes == nil {
        return nil, errors.New("scopes is a required field")
    }
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Implicit) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    scopesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    return nil
}

func (strct *Info) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "contact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "license" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"license\": ")
	if tmp, err := json.Marshal(strct.License); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "termsOfService" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"termsOfService\": ")
	if tmp, err := json.Marshal(strct.TermsOfService); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Info) UnmarshalJSON(b []byte) error {
    titleReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contact":
            if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "license":
            if err := json.Unmarshal([]byte(v), &strct.License); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "termsOfService":
            if err := json.Unmarshal([]byte(v), &strct.TermsOfService); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        }
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *License) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "identifier" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"identifier\": ")
	if tmp, err := json.Marshal(strct.Identifier); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *License) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "identifier":
            if err := json.Unmarshal([]byte(v), &strct.Identifier); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *MapOfStrings) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MapOfStrings) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Parameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "In" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameter) UnmarshalJSON(b []byte) error {
    inReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
            inReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        }
    }
    // check if in (a required property) was received
    if !inReceived {
        return errors.New("\"in\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Password) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    if strct.Scopes == nil {
        return nil, errors.New("scopes is a required field")
    }
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Password) UnmarshalJSON(b []byte) error {
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        }
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *RequestBody) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    if strct.Content == nil {
        return nil, errors.New("content is a required field")
    }
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RequestBody) UnmarshalJSON(b []byte) error {
    contentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    return nil
}

func (strct *Response) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "links" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Response) UnmarshalJSON(b []byte) error {
    descriptionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            descriptionReceived = true
        case "headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "links":
            if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
                return err
             }
        }
    }
    // check if description (a required property) was received
    if !descriptionReceived {
        return errors.New("\"description\" is required but was not present")
    }
    return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "components" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"components\": ")
	if tmp, err := json.Marshal(strct.Components); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Info" field is required
    if strct.Info == nil {
        return nil, errors.New("info is a required field")
    }
    // Marshal the "info" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"info\": ")
	if tmp, err := json.Marshal(strct.Info); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "jsonSchemaDialect" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jsonSchemaDialect\": ")
	if tmp, err := json.Marshal(strct.JsonSchemaDialect); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Openapi" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "openapi" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"openapi\": ")
	if tmp, err := json.Marshal(strct.Openapi); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "paths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "servers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"servers\": ")
	if tmp, err := json.Marshal(strct.Servers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "webhooks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"webhooks\": ")
	if tmp, err := json.Marshal(strct.Webhooks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
    infoReceived := false
    openapiReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "components":
            if err := json.Unmarshal([]byte(v), &strct.Components); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "info":
            if err := json.Unmarshal([]byte(v), &strct.Info); err != nil {
                return err
             }
            infoReceived = true
        case "jsonSchemaDialect":
            if err := json.Unmarshal([]byte(v), &strct.JsonSchemaDialect); err != nil {
                return err
             }
        case "openapi":
            if err := json.Unmarshal([]byte(v), &strct.Openapi); err != nil {
                return err
             }
            openapiReceived = true
        case "paths":
            if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
                return err
             }
        case "security":
            if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
                return err
             }
        case "servers":
            if err := json.Unmarshal([]byte(v), &strct.Servers); err != nil {
                return err
             }
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        case "webhooks":
            if err := json.Unmarshal([]byte(v), &strct.Webhooks); err != nil {
                return err
             }
        }
    }
    // check if info (a required property) was received
    if !infoReceived {
        return errors.New("\"info\" is required but was not present")
    }
    // check if openapi (a required property) was received
    if !openapiReceived {
        return errors.New("\"openapi\" is required but was not present")
    }
    return nil
}

func (strct *SecurityRequirement) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityRequirement) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "[]string" value
            var additionalValue []string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string][]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *SecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SecurityScheme) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Server) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "variables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Server) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        case "variables":
            if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
                return err
             }
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *ServerVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Default" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerVariable) UnmarshalJSON(b []byte) error {
    defaultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
            defaultReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        }
    }
    // check if default (a required property) was received
    if !defaultReceived {
        return errors.New("\"default\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}
