// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "bytes"
    "errors"
    "encoding/json"
    "fmt"
)

// AJSONSchemaForSwagger20API 
type AJSONSchemaForSwagger20API struct {

  // The base path to the API. Example: '/api'.
  BasePath string `json:"basePath,omitempty"`

  // A list of MIME types accepted by the API.
  Consumes interface{} `json:"consumes,omitempty"`
  Definitions *Definitions `json:"definitions,omitempty"`
  ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`

  // The host (name or ip) of the API. Example: 'swagger.io'
  Host string `json:"host,omitempty"`
  Info *Info `json:"info"`
  Parameters *ParameterDefinitions `json:"parameters,omitempty"`
  Paths *Paths `json:"paths"`

  // A list of MIME types the API can produce.
  Produces interface{} `json:"produces,omitempty"`
  Responses *ResponseDefinitions `json:"responses,omitempty"`
  Schemes []string `json:"schemes,omitempty"`
  Security []*SecurityRequirement `json:"security,omitempty"`
  SecurityDefinitions *SecurityDefinitions `json:"securityDefinitions,omitempty"`

  // The Swagger version of this document.
  Swagger string `json:"swagger"`
  Tags []*Tag `json:"tags,omitempty"`
}

// ApiKeySecurity 
type ApiKeySecurity struct {
  Description string `json:"description,omitempty"`
  In string `json:"in"`
  Name string `json:"name"`
  Type string `json:"type"`
}

// BasicAuthenticationSecurity 
type BasicAuthenticationSecurity struct {
  Description string `json:"description,omitempty"`
  Type string `json:"type"`
}

// BodyParameter 
type BodyParameter struct {

  // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`

  // Determines the location of the parameter.
  In string `json:"in"`

  // The name of the parameter.
  Name string `json:"name"`

  // Determines whether or not this parameter is required or optional.
  Required bool `json:"required,omitempty"`
  Schema *Schema `json:"schema"`
}

// Contact Contact information for the owners of the API.
type Contact struct {

  // The email address of the contact person/organization.
  Email string `json:"email,omitempty"`

  // The identifying name of the contact person/organization.
  Name string `json:"name,omitempty"`

  // The URL pointing to the contact information.
  Url string `json:"url,omitempty"`
}

// Examples 
type Examples struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
}

// ExternalDocs information about external documentation
type ExternalDocs struct {
  Description string `json:"description,omitempty"`
  Url string `json:"url"`
}

// FileSchema A deterministic version of a JSON Schema object.
type FileSchema struct {
  Default interface{} `json:"default,omitempty"`
  Description string `json:"description,omitempty"`
  Example interface{} `json:"example,omitempty"`
  ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`
  Format string `json:"format,omitempty"`
  ReadOnly bool `json:"readOnly,omitempty"`
  Required []string `json:"required,omitempty"`
  Title string `json:"title,omitempty"`
  Type string `json:"type"`
}

// FormDataParameterSubSchema 
type FormDataParameterSubSchema struct {

  // allows sending a parameter by name only or with an empty value.
  AllowEmptyValue bool `json:"allowEmptyValue,omitempty"`
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`

  // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`

  // Determines the location of the parameter.
  In string `json:"in,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`

  // The name of the parameter.
  Name string `json:"name,omitempty"`
  Pattern string `json:"pattern,omitempty"`

  // Determines whether or not this parameter is required or optional.
  Required bool `json:"required,omitempty"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// Header 
type Header struct {
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`
  Pattern string `json:"pattern,omitempty"`
  Type string `json:"type"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// HeaderParameterSubSchema 
type HeaderParameterSubSchema struct {
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`

  // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`

  // Determines the location of the parameter.
  In string `json:"in,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`

  // The name of the parameter.
  Name string `json:"name,omitempty"`
  Pattern string `json:"pattern,omitempty"`

  // Determines whether or not this parameter is required or optional.
  Required bool `json:"required,omitempty"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// Info General information about the API.
type Info struct {
  Contact *Contact `json:"contact,omitempty"`

  // A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  License *License `json:"license,omitempty"`

  // The terms of service for the API.
  TermsOfService string `json:"termsOfService,omitempty"`

  // A unique and precise title of the API.
  Title string `json:"title"`

  // A semantic version number of the API.
  Version string `json:"version"`
}

// JsonReference 
type JsonReference struct {
  Ref string `json:"$ref"`
}

// License 
type License struct {

  // The name of the license type. It's encouraged to use an OSI compatible license.
  Name string `json:"name"`

  // The URL pointing to the license.
  Url string `json:"url,omitempty"`
}

// NonBodyParameter 
type NonBodyParameter struct {
}

// Oauth2AccessCodeSecurity 
type Oauth2AccessCodeSecurity struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  Description string `json:"description,omitempty"`
  Flow string `json:"flow"`
  Scopes *Oauth2Scopes `json:"scopes,omitempty"`
  TokenUrl string `json:"tokenUrl"`
  Type string `json:"type"`
}

// Oauth2ApplicationSecurity 
type Oauth2ApplicationSecurity struct {
  Description string `json:"description,omitempty"`
  Flow string `json:"flow"`
  Scopes *Oauth2Scopes `json:"scopes,omitempty"`
  TokenUrl string `json:"tokenUrl"`
  Type string `json:"type"`
}

// Oauth2ImplicitSecurity 
type Oauth2ImplicitSecurity struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  Description string `json:"description,omitempty"`
  Flow string `json:"flow"`
  Scopes *Oauth2Scopes `json:"scopes,omitempty"`
  Type string `json:"type"`
}

// Oauth2PasswordSecurity 
type Oauth2PasswordSecurity struct {
  Description string `json:"description,omitempty"`
  Flow string `json:"flow"`
  Scopes *Oauth2Scopes `json:"scopes,omitempty"`
  TokenUrl string `json:"tokenUrl"`
  Type string `json:"type"`
}

// Operation 
type Operation struct {

  // A list of MIME types the API can consume.
  Consumes interface{} `json:"consumes,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`

  // A longer description of the operation, GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`

  // A unique identifier of the operation.
  OperationId string `json:"operationId,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`

  // A list of MIME types the API can produce.
  Produces interface{} `json:"produces,omitempty"`
  Responses *Responses `json:"responses"`
  Schemes []string `json:"schemes,omitempty"`
  Security []*SecurityRequirement `json:"security,omitempty"`

  // A brief summary of the operation.
  Summary string `json:"summary,omitempty"`
  Tags []string `json:"tags,omitempty"`
}

// PathItem 
type PathItem struct {
  Delete *Operation `json:"delete,omitempty"`
  Get *Operation `json:"get,omitempty"`
  Head *Operation `json:"head,omitempty"`
  Options *Operation `json:"options,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`
  Patch *Operation `json:"patch,omitempty"`
  Post *Operation `json:"post,omitempty"`
  Put *Operation `json:"put,omitempty"`
  Ref string `json:"$ref,omitempty"`
}

// PathParameterSubSchema 
type PathParameterSubSchema struct {
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`

  // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`

  // Determines the location of the parameter.
  In string `json:"in,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`

  // The name of the parameter.
  Name string `json:"name,omitempty"`
  Pattern string `json:"pattern,omitempty"`

  // Determines whether or not this parameter is required or optional.
  Required bool `json:"required"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// Paths Relative paths to the individual endpoints. They must be relative to the 'basePath'.
type Paths struct {
}

// PrimitivesItems 
type PrimitivesItems struct {
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`
  Pattern string `json:"pattern,omitempty"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// QueryParameterSubSchema 
type QueryParameterSubSchema struct {

  // allows sending a parameter by name only or with an empty value.
  AllowEmptyValue bool `json:"allowEmptyValue,omitempty"`
  CollectionFormat string `json:"collectionFormat,omitempty"`
  Default interface{} `json:"default,omitempty"`

  // A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`

  // Determines the location of the parameter.
  In string `json:"in,omitempty"`
  Items *PrimitivesItems `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`

  // The name of the parameter.
  Name string `json:"name,omitempty"`
  Pattern string `json:"pattern,omitempty"`

  // Determines whether or not this parameter is required or optional.
  Required bool `json:"required,omitempty"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// Response 
type Response struct {
  Description string `json:"description"`
  Examples *Examples `json:"examples,omitempty"`
  Headers map[string]*Header `json:"headers,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
}

// Responses Response objects names can either be any valid HTTP status code or 'default'.
type Responses struct {
}

// Root Core schema meta-schema
type Root struct {
  AdditionalItems interface{} `json:"additionalItems,omitempty"`
  AdditionalProperties interface{} `json:"additionalProperties,omitempty"`
  AllOf []interface{} `json:"allOf,omitempty"`
  AnyOf []interface{} `json:"anyOf,omitempty"`
  Default interface{} `json:"default,omitempty"`
  Definitions map[string]interface{} `json:"definitions,omitempty"`
  Dependencies map[string]interface{} `json:"dependencies,omitempty"`
  Description string `json:"description,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  Format string `json:"format,omitempty"`
  Id string `json:"id,omitempty"`
  Items interface{} `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  MaxProperties int `json:"maxProperties,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  MinProperties interface{} `json:"minProperties,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`
  Not interface{} `json:"not,omitempty"`
  OneOf []interface{} `json:"oneOf,omitempty"`
  Pattern string `json:"pattern,omitempty"`
  PatternProperties map[string]interface{} `json:"patternProperties,omitempty"`
  Properties map[string]interface{} `json:"properties,omitempty"`
  Required []string `json:"required,omitempty"`
  Schema string `json:"$schema,omitempty"`
  Title string `json:"title,omitempty"`
  Type interface{} `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
}

// Schema A deterministic version of a JSON Schema object.
type Schema struct {
  AdditionalProperties interface{} `json:"additionalProperties,omitempty"`
  AllOf []*Schema `json:"allOf,omitempty"`
  Default interface{} `json:"default,omitempty"`
  Description string `json:"description,omitempty"`
  Discriminator string `json:"discriminator,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  Example interface{} `json:"example,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`
  Format string `json:"format,omitempty"`
  Items interface{} `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  MaxProperties int `json:"maxProperties,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems interface{} `json:"minItems,omitempty"`
  MinLength interface{} `json:"minLength,omitempty"`
  MinProperties interface{} `json:"minProperties,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`
  Pattern string `json:"pattern,omitempty"`
  Properties map[string]*Schema `json:"properties,omitempty"`
  ReadOnly bool `json:"readOnly,omitempty"`
  Ref string `json:"$ref,omitempty"`
  Required []string `json:"required,omitempty"`
  Title string `json:"title,omitempty"`
  Type interface{} `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
  Xml *Xml `json:"xml,omitempty"`
}

// Tag 
type Tag struct {
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`
  Name string `json:"name"`
}

// Xml 
type Xml struct {
  Attribute bool `json:"attribute,omitempty"`
  Name string `json:"name,omitempty"`
  Namespace string `json:"namespace,omitempty"`
  Prefix string `json:"prefix,omitempty"`
  Wrapped bool `json:"wrapped,omitempty"`
}

func (strct *AJSONSchemaForSwagger20API) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "basePath" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"basePath\": ")
	if tmp, err := json.Marshal(strct.BasePath); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "consumes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"consumes\": ")
	if tmp, err := json.Marshal(strct.Consumes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "definitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"definitions\": ")
	if tmp, err := json.Marshal(strct.Definitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "host" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"host\": ")
	if tmp, err := json.Marshal(strct.Host); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Info" field is required
    if strct.Info == nil {
        return nil, errors.New("info is a required field")
    }
    // Marshal the "info" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"info\": ")
	if tmp, err := json.Marshal(strct.Info); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Paths" field is required
    if strct.Paths == nil {
        return nil, errors.New("paths is a required field")
    }
    // Marshal the "paths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "produces" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"produces\": ")
	if tmp, err := json.Marshal(strct.Produces); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "responses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"responses\": ")
	if tmp, err := json.Marshal(strct.Responses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schemes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schemes\": ")
	if tmp, err := json.Marshal(strct.Schemes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securityDefinitions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securityDefinitions\": ")
	if tmp, err := json.Marshal(strct.SecurityDefinitions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Swagger" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "swagger" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"swagger\": ")
	if tmp, err := json.Marshal(strct.Swagger); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AJSONSchemaForSwagger20API) UnmarshalJSON(b []byte) error {
    infoReceived := false
    pathsReceived := false
    swaggerReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "basePath":
            if err := json.Unmarshal([]byte(v), &strct.BasePath); err != nil {
                return err
             }
        case "consumes":
            if err := json.Unmarshal([]byte(v), &strct.Consumes); err != nil {
                return err
             }
        case "definitions":
            if err := json.Unmarshal([]byte(v), &strct.Definitions); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "host":
            if err := json.Unmarshal([]byte(v), &strct.Host); err != nil {
                return err
             }
        case "info":
            if err := json.Unmarshal([]byte(v), &strct.Info); err != nil {
                return err
             }
            infoReceived = true
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "paths":
            if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
                return err
             }
            pathsReceived = true
        case "produces":
            if err := json.Unmarshal([]byte(v), &strct.Produces); err != nil {
                return err
             }
        case "responses":
            if err := json.Unmarshal([]byte(v), &strct.Responses); err != nil {
                return err
             }
        case "schemes":
            if err := json.Unmarshal([]byte(v), &strct.Schemes); err != nil {
                return err
             }
        case "security":
            if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
                return err
             }
        case "securityDefinitions":
            if err := json.Unmarshal([]byte(v), &strct.SecurityDefinitions); err != nil {
                return err
             }
        case "swagger":
            if err := json.Unmarshal([]byte(v), &strct.Swagger); err != nil {
                return err
             }
            swaggerReceived = true
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if info (a required property) was received
    if !infoReceived {
        return errors.New("\"info\" is required but was not present")
    }
    // check if paths (a required property) was received
    if !pathsReceived {
        return errors.New("\"paths\" is required but was not present")
    }
    // check if swagger (a required property) was received
    if !swaggerReceived {
        return errors.New("\"swagger\" is required but was not present")
    }
    return nil
}

func (strct *ApiKeySecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "In" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ApiKeySecurity) UnmarshalJSON(b []byte) error {
    inReceived := false
    nameReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
            inReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if in (a required property) was received
    if !inReceived {
        return errors.New("\"in\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *BasicAuthenticationSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BasicAuthenticationSecurity) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *BodyParameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "In" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Schema" field is required
    if strct.Schema == nil {
        return nil, errors.New("schema is a required field")
    }
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BodyParameter) UnmarshalJSON(b []byte) error {
    inReceived := false
    nameReceived := false
    schemaReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
            inReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
            schemaReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if in (a required property) was received
    if !inReceived {
        return errors.New("\"in\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if schema (a required property) was received
    if !schemaReceived {
        return errors.New("\"schema\" is required but was not present")
    }
    return nil
}

func (strct *Contact) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "email" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"email\": ")
	if tmp, err := json.Marshal(strct.Email); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Contact) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "email":
            if err := json.Unmarshal([]byte(v), &strct.Email); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Examples) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Examples) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ExternalDocs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExternalDocs) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *FileSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "readOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"readOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FileSchema) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "readOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *FormDataParameterSubSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowEmptyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowEmptyValue\": ")
	if tmp, err := json.Marshal(strct.AllowEmptyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FormDataParameterSubSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowEmptyValue":
            if err := json.Unmarshal([]byte(v), &strct.AllowEmptyValue); err != nil {
                return err
             }
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Header) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Header) UnmarshalJSON(b []byte) error {
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *HeaderParameterSubSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HeaderParameterSubSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Info) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "contact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "license" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"license\": ")
	if tmp, err := json.Marshal(strct.License); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "termsOfService" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"termsOfService\": ")
	if tmp, err := json.Marshal(strct.TermsOfService); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Info) UnmarshalJSON(b []byte) error {
    titleReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contact":
            if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "license":
            if err := json.Unmarshal([]byte(v), &strct.License); err != nil {
                return err
             }
        case "termsOfService":
            if err := json.Unmarshal([]byte(v), &strct.TermsOfService); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *JsonReference) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Ref" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "$ref" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *JsonReference) UnmarshalJSON(b []byte) error {
    $refReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "$ref":
            if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
                return err
             }
            $refReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if $ref (a required property) was received
    if !$refReceived {
        return errors.New("\"$ref\" is required but was not present")
    }
    return nil
}

func (strct *License) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *License) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Oauth2AccessCodeSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Flow" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "flow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flow\": ")
	if tmp, err := json.Marshal(strct.Flow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2AccessCodeSecurity) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    flowReceived := false
    tokenUrlReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "flow":
            if err := json.Unmarshal([]byte(v), &strct.Flow); err != nil {
                return err
             }
            flowReceived = true
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if flow (a required property) was received
    if !flowReceived {
        return errors.New("\"flow\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Oauth2ApplicationSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Flow" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "flow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flow\": ")
	if tmp, err := json.Marshal(strct.Flow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2ApplicationSecurity) UnmarshalJSON(b []byte) error {
    flowReceived := false
    tokenUrlReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "flow":
            if err := json.Unmarshal([]byte(v), &strct.Flow); err != nil {
                return err
             }
            flowReceived = true
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if flow (a required property) was received
    if !flowReceived {
        return errors.New("\"flow\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Oauth2ImplicitSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Flow" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "flow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flow\": ")
	if tmp, err := json.Marshal(strct.Flow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2ImplicitSecurity) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    flowReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "flow":
            if err := json.Unmarshal([]byte(v), &strct.Flow); err != nil {
                return err
             }
            flowReceived = true
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if flow (a required property) was received
    if !flowReceived {
        return errors.New("\"flow\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Oauth2PasswordSecurity) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Flow" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "flow" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flow\": ")
	if tmp, err := json.Marshal(strct.Flow); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Oauth2PasswordSecurity) UnmarshalJSON(b []byte) error {
    flowReceived := false
    tokenUrlReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "flow":
            if err := json.Unmarshal([]byte(v), &strct.Flow); err != nil {
                return err
             }
            flowReceived = true
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if flow (a required property) was received
    if !flowReceived {
        return errors.New("\"flow\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Operation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "consumes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"consumes\": ")
	if tmp, err := json.Marshal(strct.Consumes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operationId\": ")
	if tmp, err := json.Marshal(strct.OperationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "produces" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"produces\": ")
	if tmp, err := json.Marshal(strct.Produces); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Responses" field is required
    if strct.Responses == nil {
        return nil, errors.New("responses is a required field")
    }
    // Marshal the "responses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"responses\": ")
	if tmp, err := json.Marshal(strct.Responses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schemes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schemes\": ")
	if tmp, err := json.Marshal(strct.Schemes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Operation) UnmarshalJSON(b []byte) error {
    responsesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "consumes":
            if err := json.Unmarshal([]byte(v), &strct.Consumes); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "operationId":
            if err := json.Unmarshal([]byte(v), &strct.OperationId); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "produces":
            if err := json.Unmarshal([]byte(v), &strct.Produces); err != nil {
                return err
             }
        case "responses":
            if err := json.Unmarshal([]byte(v), &strct.Responses); err != nil {
                return err
             }
            responsesReceived = true
        case "schemes":
            if err := json.Unmarshal([]byte(v), &strct.Schemes); err != nil {
                return err
             }
        case "security":
            if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if responses (a required property) was received
    if !responsesReceived {
        return errors.New("\"responses\" is required but was not present")
    }
    return nil
}

func (strct *PathItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "delete" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"delete\": ")
	if tmp, err := json.Marshal(strct.Delete); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "get" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"get\": ")
	if tmp, err := json.Marshal(strct.Get); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "head" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"head\": ")
	if tmp, err := json.Marshal(strct.Head); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "options" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"options\": ")
	if tmp, err := json.Marshal(strct.Options); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "patch" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"patch\": ")
	if tmp, err := json.Marshal(strct.Patch); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "post" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"post\": ")
	if tmp, err := json.Marshal(strct.Post); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "put" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"put\": ")
	if tmp, err := json.Marshal(strct.Put); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "$ref" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "delete":
            if err := json.Unmarshal([]byte(v), &strct.Delete); err != nil {
                return err
             }
        case "get":
            if err := json.Unmarshal([]byte(v), &strct.Get); err != nil {
                return err
             }
        case "head":
            if err := json.Unmarshal([]byte(v), &strct.Head); err != nil {
                return err
             }
        case "options":
            if err := json.Unmarshal([]byte(v), &strct.Options); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "patch":
            if err := json.Unmarshal([]byte(v), &strct.Patch); err != nil {
                return err
             }
        case "post":
            if err := json.Unmarshal([]byte(v), &strct.Post); err != nil {
                return err
             }
        case "put":
            if err := json.Unmarshal([]byte(v), &strct.Put); err != nil {
                return err
             }
        case "$ref":
            if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PathParameterSubSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Required" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathParameterSubSchema) UnmarshalJSON(b []byte) error {
    requiredReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
            requiredReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if required (a required property) was received
    if !requiredReceived {
        return errors.New("\"required\" is required but was not present")
    }
    return nil
}

func (strct *Paths) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Paths) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PrimitivesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PrimitivesItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *QueryParameterSubSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowEmptyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowEmptyValue\": ")
	if tmp, err := json.Marshal(strct.AllowEmptyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "collectionFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"collectionFormat\": ")
	if tmp, err := json.Marshal(strct.CollectionFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *QueryParameterSubSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowEmptyValue":
            if err := json.Unmarshal([]byte(v), &strct.AllowEmptyValue); err != nil {
                return err
             }
        case "collectionFormat":
            if err := json.Unmarshal([]byte(v), &strct.CollectionFormat); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Response) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "examples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Response) UnmarshalJSON(b []byte) error {
    descriptionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            descriptionReceived = true
        case "examples":
            if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
                return err
             }
        case "headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if description (a required property) was received
    if !descriptionReceived {
        return errors.New("\"description\" is required but was not present")
    }
    return nil
}

func (strct *Responses) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Responses) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Schema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "additionalProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"additionalProperties\": ")
	if tmp, err := json.Marshal(strct.AdditionalProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "allOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allOf\": ")
	if tmp, err := json.Marshal(strct.AllOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "discriminator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"discriminator\": ")
	if tmp, err := json.Marshal(strct.Discriminator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxProperties\": ")
	if tmp, err := json.Marshal(strct.MaxProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minProperties\": ")
	if tmp, err := json.Marshal(strct.MinProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "readOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"readOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "$ref" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "xml" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"xml\": ")
	if tmp, err := json.Marshal(strct.Xml); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Schema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "additionalProperties":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalProperties); err != nil {
                return err
             }
        case "allOf":
            if err := json.Unmarshal([]byte(v), &strct.AllOf); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "discriminator":
            if err := json.Unmarshal([]byte(v), &strct.Discriminator); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maxProperties":
            if err := json.Unmarshal([]byte(v), &strct.MaxProperties); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minProperties":
            if err := json.Unmarshal([]byte(v), &strct.MinProperties); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
        case "readOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "$ref":
            if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        case "xml":
            if err := json.Unmarshal([]byte(v), &strct.Xml); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Xml) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "attribute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"attribute\": ")
	if tmp, err := json.Marshal(strct.Attribute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "wrapped" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"wrapped\": ")
	if tmp, err := json.Marshal(strct.Wrapped); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Xml) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "attribute":
            if err := json.Unmarshal([]byte(v), &strct.Attribute); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "wrapped":
            if err := json.Unmarshal([]byte(v), &strct.Wrapped); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
