// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "encoding/json"
    "fmt"
    "errors"
    "bytes"
)

// APIKeySecurityScheme 
type APIKeySecurityScheme struct {
  Description string `json:"description,omitempty"`
  In string `json:"in"`
  Name string `json:"name"`
  Type string `json:"type"`
}

// AuthorizationCodeOAuthFlow 
type AuthorizationCodeOAuthFlow struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes map[string]string `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// Callbacks 
type Callbacks struct {
}

// ClientCredentialsFlow 
type ClientCredentialsFlow struct {
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes map[string]string `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// Components 
type Components struct {
  Callbacks *Callbacks `json:"callbacks,omitempty"`
  Examples *Examples `json:"examples,omitempty"`
  Headers *Headers `json:"headers,omitempty"`
  Links *Links `json:"links,omitempty"`
  Parameters *Parameters `json:"parameters,omitempty"`
  RequestBodies *RequestBodies `json:"requestBodies,omitempty"`
  Responses *Responses `json:"responses,omitempty"`
  Schemas *Schemas `json:"schemas,omitempty"`
  SecuritySchemes *SecuritySchemes `json:"securitySchemes,omitempty"`
}

// Contact 
type Contact struct {
  Email string `json:"email,omitempty"`
  Name string `json:"name,omitempty"`
  Url string `json:"url,omitempty"`
}

// Discriminator 
type Discriminator struct {
  Mapping map[string]string `json:"mapping,omitempty"`
  PropertyName string `json:"propertyName"`
}

// Encoding 
type Encoding struct {
  AllowReserved bool `json:"allowReserved,omitempty"`
  ContentType string `json:"contentType,omitempty"`
  Explode bool `json:"explode,omitempty"`
  Headers map[string]interface{} `json:"headers,omitempty"`
  Style string `json:"style,omitempty"`
}

// Example 
type Example struct {
  Description string `json:"description,omitempty"`
  ExternalValue string `json:"externalValue,omitempty"`
  Summary string `json:"summary,omitempty"`
  Value interface{} `json:"value,omitempty"`
}

// Examples 
type Examples struct {
}

// ExternalDocumentation 
type ExternalDocumentation struct {
  Description string `json:"description,omitempty"`
  Url string `json:"url"`
}

// HTTPSecurityScheme 
type HTTPSecurityScheme struct {
  BearerFormat string `json:"bearerFormat,omitempty"`
  Description string `json:"description,omitempty"`
  Scheme string `json:"scheme"`
  Type string `json:"type"`
}

// Header 
type Header struct {
  AllowEmptyValue bool `json:"allowEmptyValue,omitempty"`
  AllowReserved bool `json:"allowReserved,omitempty"`
  Content map[string]*MediaType `json:"content,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  Example interface{} `json:"example,omitempty"`
  Examples map[string]interface{} `json:"examples,omitempty"`
  Explode bool `json:"explode,omitempty"`
  Required bool `json:"required,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
  Style string `json:"style,omitempty"`
}

// Headers 
type Headers struct {
}

// ImplicitOAuthFlow 
type ImplicitOAuthFlow struct {
  AuthorizationUrl string `json:"authorizationUrl"`
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes map[string]string `json:"scopes"`
}

// Info 
type Info struct {
  Contact *Contact `json:"contact,omitempty"`
  Description string `json:"description,omitempty"`
  License *License `json:"license,omitempty"`
  TermsOfService string `json:"termsOfService,omitempty"`
  Title string `json:"title"`
  Version string `json:"version"`
}

// License 
type License struct {
  Name string `json:"name"`
  Url string `json:"url,omitempty"`
}

// Link 
type Link struct {
  Description string `json:"description,omitempty"`
  OperationId string `json:"operationId,omitempty"`
  OperationRef string `json:"operationRef,omitempty"`
  Parameters map[string]interface{} `json:"parameters,omitempty"`
  RequestBody interface{} `json:"requestBody,omitempty"`
  Server *Server `json:"server,omitempty"`
}

// Links 
type Links struct {
}

// MediaType 
type MediaType struct {
  Encoding map[string]*Encoding `json:"encoding,omitempty"`
  Example interface{} `json:"example,omitempty"`
  Examples map[string]interface{} `json:"examples,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
}

// OAuth2SecurityScheme 
type OAuth2SecurityScheme struct {
  Description string `json:"description,omitempty"`
  Flows *OAuthFlows `json:"flows"`
  Type string `json:"type"`
}

// OAuthFlows 
type OAuthFlows struct {
  AuthorizationCode *AuthorizationCodeOAuthFlow `json:"authorizationCode,omitempty"`
  ClientCredentials *ClientCredentialsFlow `json:"clientCredentials,omitempty"`
  Implicit *ImplicitOAuthFlow `json:"implicit,omitempty"`
  Password *PasswordOAuthFlow `json:"password,omitempty"`
}

// OpenIdConnectSecurityScheme 
type OpenIdConnectSecurityScheme struct {
  Description string `json:"description,omitempty"`
  OpenIdConnectUrl string `json:"openIdConnectUrl"`
  Type string `json:"type"`
}

// Operation 
type Operation struct {
  Callbacks map[string]interface{} `json:"callbacks,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  OperationId string `json:"operationId,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`
  RequestBody interface{} `json:"requestBody,omitempty"`
  Responses *Responses `json:"responses"`
  Security []map[string][]string `json:"security,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Summary string `json:"summary,omitempty"`
  Tags []string `json:"tags,omitempty"`
}

// Parameter 
type Parameter struct {
  AllowEmptyValue bool `json:"allowEmptyValue,omitempty"`
  AllowReserved bool `json:"allowReserved,omitempty"`
  Content map[string]*MediaType `json:"content,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  Example interface{} `json:"example,omitempty"`
  Examples map[string]interface{} `json:"examples,omitempty"`
  Explode bool `json:"explode,omitempty"`
  In string `json:"in"`
  Name string `json:"name"`
  Required bool `json:"required,omitempty"`
  Schema interface{} `json:"schema,omitempty"`
  Style string `json:"style,omitempty"`
}

// Parameters 
type Parameters struct {
}

// PasswordOAuthFlow 
type PasswordOAuthFlow struct {
  RefreshUrl string `json:"refreshUrl,omitempty"`
  Scopes map[string]string `json:"scopes"`
  TokenUrl string `json:"tokenUrl"`
}

// PathItem 
type PathItem struct {
  Description string `json:"description,omitempty"`
  Parameters []interface{} `json:"parameters,omitempty"`
  Ref string `json:"$ref,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Summary string `json:"summary,omitempty"`
}

// Paths 
type Paths struct {
}

// Reference 
type Reference struct {
}

// RequestBodies 
type RequestBodies struct {
}

// RequestBody 
type RequestBody struct {
  Content map[string]*MediaType `json:"content"`
  Description string `json:"description,omitempty"`
  Required bool `json:"required,omitempty"`
}

// Response 
type Response struct {
  Content map[string]*MediaType `json:"content,omitempty"`
  Description string `json:"description"`
  Headers map[string]interface{} `json:"headers,omitempty"`
  Links map[string]interface{} `json:"links,omitempty"`
}

// Responses 
type Responses struct {
}

// Root The description of OpenAPI v3.0.x documents, as defined by https://spec.openapis.org/oas/v3.0.3
type Root struct {
  Components *Components `json:"components,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  Info *Info `json:"info"`
  Openapi string `json:"openapi"`
  Paths *Paths `json:"paths"`
  Security []*SecurityRequirement `json:"security,omitempty"`
  Servers []*Server `json:"servers,omitempty"`
  Tags []*Tag `json:"tags,omitempty"`
}

// Schema 
type Schema struct {
  AdditionalProperties interface{} `json:"additionalProperties,omitempty"`
  AllOf []interface{} `json:"allOf,omitempty"`
  AnyOf []interface{} `json:"anyOf,omitempty"`
  Default interface{} `json:"default,omitempty"`
  Deprecated bool `json:"deprecated,omitempty"`
  Description string `json:"description,omitempty"`
  Discriminator *Discriminator `json:"discriminator,omitempty"`
  Enum []interface{} `json:"enum,omitempty"`
  Example interface{} `json:"example,omitempty"`
  ExclusiveMaximum bool `json:"exclusiveMaximum,omitempty"`
  ExclusiveMinimum bool `json:"exclusiveMinimum,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  Format string `json:"format,omitempty"`
  Items interface{} `json:"items,omitempty"`
  MaxItems int `json:"maxItems,omitempty"`
  MaxLength int `json:"maxLength,omitempty"`
  MaxProperties int `json:"maxProperties,omitempty"`
  Maximum float64 `json:"maximum,omitempty"`
  MinItems int `json:"minItems,omitempty"`
  MinLength int `json:"minLength,omitempty"`
  MinProperties int `json:"minProperties,omitempty"`
  Minimum float64 `json:"minimum,omitempty"`
  MultipleOf float64 `json:"multipleOf,omitempty"`
  Not interface{} `json:"not,omitempty"`
  Nullable bool `json:"nullable,omitempty"`
  OneOf []interface{} `json:"oneOf,omitempty"`
  Pattern string `json:"pattern,omitempty"`
  Properties map[string]interface{} `json:"properties,omitempty"`
  ReadOnly bool `json:"readOnly,omitempty"`
  Required []string `json:"required,omitempty"`
  Title string `json:"title,omitempty"`
  Type string `json:"type,omitempty"`
  UniqueItems bool `json:"uniqueItems,omitempty"`
  WriteOnly bool `json:"writeOnly,omitempty"`
  Xml *XML `json:"xml,omitempty"`
}

// Schemas 
type Schemas struct {
}

// SecuritySchemes 
type SecuritySchemes struct {
}

// Server 
type Server struct {
  Description string `json:"description,omitempty"`
  Url string `json:"url"`
  Variables map[string]*ServerVariable `json:"variables,omitempty"`
}

// ServerVariable 
type ServerVariable struct {
  Default string `json:"default"`
  Description string `json:"description,omitempty"`
  Enum []string `json:"enum,omitempty"`
}

// Tag 
type Tag struct {
  Description string `json:"description,omitempty"`
  ExternalDocs *ExternalDocumentation `json:"externalDocs,omitempty"`
  Name string `json:"name"`
}

// XML 
type XML struct {
  Attribute bool `json:"attribute,omitempty"`
  Name string `json:"name,omitempty"`
  Namespace string `json:"namespace,omitempty"`
  Prefix string `json:"prefix,omitempty"`
  Wrapped bool `json:"wrapped,omitempty"`
}

func (strct *APIKeySecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "In" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *APIKeySecurityScheme) UnmarshalJSON(b []byte) error {
    inReceived := false
    nameReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
            inReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if in (a required property) was received
    if !inReceived {
        return errors.New("\"in\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *AuthorizationCodeOAuthFlow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AuthorizationCodeOAuthFlow) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *ClientCredentialsFlow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ClientCredentialsFlow) UnmarshalJSON(b []byte) error {
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *Components) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "callbacks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"callbacks\": ")
	if tmp, err := json.Marshal(strct.Callbacks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "examples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "links" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requestBodies" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requestBodies\": ")
	if tmp, err := json.Marshal(strct.RequestBodies); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "responses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"responses\": ")
	if tmp, err := json.Marshal(strct.Responses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schemas" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schemas\": ")
	if tmp, err := json.Marshal(strct.Schemas); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "securitySchemes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"securitySchemes\": ")
	if tmp, err := json.Marshal(strct.SecuritySchemes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Components) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "callbacks":
            if err := json.Unmarshal([]byte(v), &strct.Callbacks); err != nil {
                return err
             }
        case "examples":
            if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
                return err
             }
        case "headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "links":
            if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "requestBodies":
            if err := json.Unmarshal([]byte(v), &strct.RequestBodies); err != nil {
                return err
             }
        case "responses":
            if err := json.Unmarshal([]byte(v), &strct.Responses); err != nil {
                return err
             }
        case "schemas":
            if err := json.Unmarshal([]byte(v), &strct.Schemas); err != nil {
                return err
             }
        case "securitySchemes":
            if err := json.Unmarshal([]byte(v), &strct.SecuritySchemes); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Contact) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "email" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"email\": ")
	if tmp, err := json.Marshal(strct.Email); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Contact) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "email":
            if err := json.Unmarshal([]byte(v), &strct.Email); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Discriminator) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "mapping" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"mapping\": ")
	if tmp, err := json.Marshal(strct.Mapping); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PropertyName" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "propertyName" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"propertyName\": ")
	if tmp, err := json.Marshal(strct.PropertyName); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Discriminator) UnmarshalJSON(b []byte) error {
    propertyNameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "mapping":
            if err := json.Unmarshal([]byte(v), &strct.Mapping); err != nil {
                return err
             }
        case "propertyName":
            if err := json.Unmarshal([]byte(v), &strct.PropertyName); err != nil {
                return err
             }
            propertyNameReceived = true
        }
    }
    // check if propertyName (a required property) was received
    if !propertyNameReceived {
        return errors.New("\"propertyName\" is required but was not present")
    }
    return nil
}

func (strct *Encoding) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowReserved" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowReserved\": ")
	if tmp, err := json.Marshal(strct.AllowReserved); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "contentType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contentType\": ")
	if tmp, err := json.Marshal(strct.ContentType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "explode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"explode\": ")
	if tmp, err := json.Marshal(strct.Explode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "style" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"style\": ")
	if tmp, err := json.Marshal(strct.Style); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Encoding) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowReserved":
            if err := json.Unmarshal([]byte(v), &strct.AllowReserved); err != nil {
                return err
             }
        case "contentType":
            if err := json.Unmarshal([]byte(v), &strct.ContentType); err != nil {
                return err
             }
        case "explode":
            if err := json.Unmarshal([]byte(v), &strct.Explode); err != nil {
                return err
             }
        case "headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "style":
            if err := json.Unmarshal([]byte(v), &strct.Style); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Example) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalValue\": ")
	if tmp, err := json.Marshal(strct.ExternalValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "value" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Example) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalValue":
            if err := json.Unmarshal([]byte(v), &strct.ExternalValue); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "value":
            if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ExternalDocumentation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ExternalDocumentation) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *HTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "bearerFormat" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"bearerFormat\": ")
	if tmp, err := json.Marshal(strct.BearerFormat); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scheme" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scheme" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scheme\": ")
	if tmp, err := json.Marshal(strct.Scheme); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HTTPSecurityScheme) UnmarshalJSON(b []byte) error {
    schemeReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "bearerFormat":
            if err := json.Unmarshal([]byte(v), &strct.BearerFormat); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "scheme":
            if err := json.Unmarshal([]byte(v), &strct.Scheme); err != nil {
                return err
             }
            schemeReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if scheme (a required property) was received
    if !schemeReceived {
        return errors.New("\"scheme\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Header) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowEmptyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowEmptyValue\": ")
	if tmp, err := json.Marshal(strct.AllowEmptyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "allowReserved" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowReserved\": ")
	if tmp, err := json.Marshal(strct.AllowReserved); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "examples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "explode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"explode\": ")
	if tmp, err := json.Marshal(strct.Explode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "style" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"style\": ")
	if tmp, err := json.Marshal(strct.Style); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Header) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowEmptyValue":
            if err := json.Unmarshal([]byte(v), &strct.AllowEmptyValue); err != nil {
                return err
             }
        case "allowReserved":
            if err := json.Unmarshal([]byte(v), &strct.AllowReserved); err != nil {
                return err
             }
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "examples":
            if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
                return err
             }
        case "explode":
            if err := json.Unmarshal([]byte(v), &strct.Explode); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        case "style":
            if err := json.Unmarshal([]byte(v), &strct.Style); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *ImplicitOAuthFlow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AuthorizationUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "authorizationUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationUrl\": ")
	if tmp, err := json.Marshal(strct.AuthorizationUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ImplicitOAuthFlow) UnmarshalJSON(b []byte) error {
    authorizationUrlReceived := false
    scopesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationUrl":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationUrl); err != nil {
                return err
             }
            authorizationUrlReceived = true
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if authorizationUrl (a required property) was received
    if !authorizationUrlReceived {
        return errors.New("\"authorizationUrl\" is required but was not present")
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    return nil
}

func (strct *Info) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "contact" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "license" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"license\": ")
	if tmp, err := json.Marshal(strct.License); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "termsOfService" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"termsOfService\": ")
	if tmp, err := json.Marshal(strct.TermsOfService); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Version" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Info) UnmarshalJSON(b []byte) error {
    titleReceived := false
    versionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "contact":
            if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "license":
            if err := json.Unmarshal([]byte(v), &strct.License); err != nil {
                return err
             }
        case "termsOfService":
            if err := json.Unmarshal([]byte(v), &strct.TermsOfService); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
            versionReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    // check if version (a required property) was received
    if !versionReceived {
        return errors.New("\"version\" is required but was not present")
    }
    return nil
}

func (strct *License) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *License) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Link) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operationId\": ")
	if tmp, err := json.Marshal(strct.OperationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operationRef" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operationRef\": ")
	if tmp, err := json.Marshal(strct.OperationRef); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requestBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requestBody\": ")
	if tmp, err := json.Marshal(strct.RequestBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "server" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"server\": ")
	if tmp, err := json.Marshal(strct.Server); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Link) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "operationId":
            if err := json.Unmarshal([]byte(v), &strct.OperationId); err != nil {
                return err
             }
        case "operationRef":
            if err := json.Unmarshal([]byte(v), &strct.OperationRef); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "requestBody":
            if err := json.Unmarshal([]byte(v), &strct.RequestBody); err != nil {
                return err
             }
        case "server":
            if err := json.Unmarshal([]byte(v), &strct.Server); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *MediaType) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "encoding" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"encoding\": ")
	if tmp, err := json.Marshal(strct.Encoding); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "examples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MediaType) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "encoding":
            if err := json.Unmarshal([]byte(v), &strct.Encoding); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "examples":
            if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OAuth2SecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Flows" field is required
    if strct.Flows == nil {
        return nil, errors.New("flows is a required field")
    }
    // Marshal the "flows" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"flows\": ")
	if tmp, err := json.Marshal(strct.Flows); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OAuth2SecurityScheme) UnmarshalJSON(b []byte) error {
    flowsReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "flows":
            if err := json.Unmarshal([]byte(v), &strct.Flows); err != nil {
                return err
             }
            flowsReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if flows (a required property) was received
    if !flowsReceived {
        return errors.New("\"flows\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *OAuthFlows) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "authorizationCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"authorizationCode\": ")
	if tmp, err := json.Marshal(strct.AuthorizationCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "clientCredentials" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"clientCredentials\": ")
	if tmp, err := json.Marshal(strct.ClientCredentials); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "implicit" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"implicit\": ")
	if tmp, err := json.Marshal(strct.Implicit); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "password" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"password\": ")
	if tmp, err := json.Marshal(strct.Password); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OAuthFlows) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "authorizationCode":
            if err := json.Unmarshal([]byte(v), &strct.AuthorizationCode); err != nil {
                return err
             }
        case "clientCredentials":
            if err := json.Unmarshal([]byte(v), &strct.ClientCredentials); err != nil {
                return err
             }
        case "implicit":
            if err := json.Unmarshal([]byte(v), &strct.Implicit); err != nil {
                return err
             }
        case "password":
            if err := json.Unmarshal([]byte(v), &strct.Password); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *OpenIdConnectSecurityScheme) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "OpenIdConnectUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "openIdConnectUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"openIdConnectUrl\": ")
	if tmp, err := json.Marshal(strct.OpenIdConnectUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Type" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *OpenIdConnectSecurityScheme) UnmarshalJSON(b []byte) error {
    openIdConnectUrlReceived := false
    typeReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "openIdConnectUrl":
            if err := json.Unmarshal([]byte(v), &strct.OpenIdConnectUrl); err != nil {
                return err
             }
            openIdConnectUrlReceived = true
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
            typeReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if openIdConnectUrl (a required property) was received
    if !openIdConnectUrlReceived {
        return errors.New("\"openIdConnectUrl\" is required but was not present")
    }
    // check if type (a required property) was received
    if !typeReceived {
        return errors.New("\"type\" is required but was not present")
    }
    return nil
}

func (strct *Operation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "callbacks" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"callbacks\": ")
	if tmp, err := json.Marshal(strct.Callbacks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "operationId" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"operationId\": ")
	if tmp, err := json.Marshal(strct.OperationId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "requestBody" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"requestBody\": ")
	if tmp, err := json.Marshal(strct.RequestBody); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Responses" field is required
    if strct.Responses == nil {
        return nil, errors.New("responses is a required field")
    }
    // Marshal the "responses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"responses\": ")
	if tmp, err := json.Marshal(strct.Responses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "servers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"servers\": ")
	if tmp, err := json.Marshal(strct.Servers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Operation) UnmarshalJSON(b []byte) error {
    responsesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "callbacks":
            if err := json.Unmarshal([]byte(v), &strct.Callbacks); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "operationId":
            if err := json.Unmarshal([]byte(v), &strct.OperationId); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "requestBody":
            if err := json.Unmarshal([]byte(v), &strct.RequestBody); err != nil {
                return err
             }
        case "responses":
            if err := json.Unmarshal([]byte(v), &strct.Responses); err != nil {
                return err
             }
            responsesReceived = true
        case "security":
            if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
                return err
             }
        case "servers":
            if err := json.Unmarshal([]byte(v), &strct.Servers); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if responses (a required property) was received
    if !responsesReceived {
        return errors.New("\"responses\" is required but was not present")
    }
    return nil
}

func (strct *Parameter) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "allowEmptyValue" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowEmptyValue\": ")
	if tmp, err := json.Marshal(strct.AllowEmptyValue); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "allowReserved" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allowReserved\": ")
	if tmp, err := json.Marshal(strct.AllowReserved); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "examples" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"examples\": ")
	if tmp, err := json.Marshal(strct.Examples); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "explode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"explode\": ")
	if tmp, err := json.Marshal(strct.Explode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "In" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "in" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"in\": ")
	if tmp, err := json.Marshal(strct.In); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "style" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"style\": ")
	if tmp, err := json.Marshal(strct.Style); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Parameter) UnmarshalJSON(b []byte) error {
    inReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "allowEmptyValue":
            if err := json.Unmarshal([]byte(v), &strct.AllowEmptyValue); err != nil {
                return err
             }
        case "allowReserved":
            if err := json.Unmarshal([]byte(v), &strct.AllowReserved); err != nil {
                return err
             }
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "examples":
            if err := json.Unmarshal([]byte(v), &strct.Examples); err != nil {
                return err
             }
        case "explode":
            if err := json.Unmarshal([]byte(v), &strct.Explode); err != nil {
                return err
             }
        case "in":
            if err := json.Unmarshal([]byte(v), &strct.In); err != nil {
                return err
             }
            inReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        case "style":
            if err := json.Unmarshal([]byte(v), &strct.Style); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if in (a required property) was received
    if !inReceived {
        return errors.New("\"in\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *PasswordOAuthFlow) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "refreshUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"refreshUrl\": ")
	if tmp, err := json.Marshal(strct.RefreshUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Scopes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "scopes" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"scopes\": ")
	if tmp, err := json.Marshal(strct.Scopes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TokenUrl" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "tokenUrl" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tokenUrl\": ")
	if tmp, err := json.Marshal(strct.TokenUrl); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PasswordOAuthFlow) UnmarshalJSON(b []byte) error {
    scopesReceived := false
    tokenUrlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "refreshUrl":
            if err := json.Unmarshal([]byte(v), &strct.RefreshUrl); err != nil {
                return err
             }
        case "scopes":
            if err := json.Unmarshal([]byte(v), &strct.Scopes); err != nil {
                return err
             }
            scopesReceived = true
        case "tokenUrl":
            if err := json.Unmarshal([]byte(v), &strct.TokenUrl); err != nil {
                return err
             }
            tokenUrlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if scopes (a required property) was received
    if !scopesReceived {
        return errors.New("\"scopes\" is required but was not present")
    }
    // check if tokenUrl (a required property) was received
    if !tokenUrlReceived {
        return errors.New("\"tokenUrl\" is required but was not present")
    }
    return nil
}

func (strct *PathItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "parameters" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"parameters\": ")
	if tmp, err := json.Marshal(strct.Parameters); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "$ref" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$ref\": ")
	if tmp, err := json.Marshal(strct.Ref); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "servers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"servers\": ")
	if tmp, err := json.Marshal(strct.Servers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PathItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "parameters":
            if err := json.Unmarshal([]byte(v), &strct.Parameters); err != nil {
                return err
             }
        case "$ref":
            if err := json.Unmarshal([]byte(v), &strct.Ref); err != nil {
                return err
             }
        case "servers":
            if err := json.Unmarshal([]byte(v), &strct.Servers); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Paths) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Paths) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *RequestBody) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Content" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *RequestBody) UnmarshalJSON(b []byte) error {
    contentReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
            contentReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if content (a required property) was received
    if !contentReceived {
        return errors.New("\"content\" is required but was not present")
    }
    return nil
}

func (strct *Response) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "content" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"content\": ")
	if tmp, err := json.Marshal(strct.Content); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "headers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"headers\": ")
	if tmp, err := json.Marshal(strct.Headers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "links" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Response) UnmarshalJSON(b []byte) error {
    descriptionReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "content":
            if err := json.Unmarshal([]byte(v), &strct.Content); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            descriptionReceived = true
        case "headers":
            if err := json.Unmarshal([]byte(v), &strct.Headers); err != nil {
                return err
             }
        case "links":
            if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if description (a required property) was received
    if !descriptionReceived {
        return errors.New("\"description\" is required but was not present")
    }
    return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "components" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"components\": ")
	if tmp, err := json.Marshal(strct.Components); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Info" field is required
    if strct.Info == nil {
        return nil, errors.New("info is a required field")
    }
    // Marshal the "info" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"info\": ")
	if tmp, err := json.Marshal(strct.Info); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Openapi" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "openapi" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"openapi\": ")
	if tmp, err := json.Marshal(strct.Openapi); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Paths" field is required
    if strct.Paths == nil {
        return nil, errors.New("paths is a required field")
    }
    // Marshal the "paths" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "security" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"security\": ")
	if tmp, err := json.Marshal(strct.Security); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "servers" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"servers\": ")
	if tmp, err := json.Marshal(strct.Servers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tags" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"tags\": ")
	if tmp, err := json.Marshal(strct.Tags); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
    infoReceived := false
    openapiReceived := false
    pathsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "components":
            if err := json.Unmarshal([]byte(v), &strct.Components); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "info":
            if err := json.Unmarshal([]byte(v), &strct.Info); err != nil {
                return err
             }
            infoReceived = true
        case "openapi":
            if err := json.Unmarshal([]byte(v), &strct.Openapi); err != nil {
                return err
             }
            openapiReceived = true
        case "paths":
            if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
                return err
             }
            pathsReceived = true
        case "security":
            if err := json.Unmarshal([]byte(v), &strct.Security); err != nil {
                return err
             }
        case "servers":
            if err := json.Unmarshal([]byte(v), &strct.Servers); err != nil {
                return err
             }
        case "tags":
            if err := json.Unmarshal([]byte(v), &strct.Tags); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if info (a required property) was received
    if !infoReceived {
        return errors.New("\"info\" is required but was not present")
    }
    // check if openapi (a required property) was received
    if !openapiReceived {
        return errors.New("\"openapi\" is required but was not present")
    }
    // check if paths (a required property) was received
    if !pathsReceived {
        return errors.New("\"paths\" is required but was not present")
    }
    return nil
}

func (strct *Schema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "additionalProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"additionalProperties\": ")
	if tmp, err := json.Marshal(strct.AdditionalProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "allOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"allOf\": ")
	if tmp, err := json.Marshal(strct.AllOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "anyOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"anyOf\": ")
	if tmp, err := json.Marshal(strct.AnyOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "deprecated" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"deprecated\": ")
	if tmp, err := json.Marshal(strct.Deprecated); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "discriminator" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"discriminator\": ")
	if tmp, err := json.Marshal(strct.Discriminator); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "example" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"example\": ")
	if tmp, err := json.Marshal(strct.Example); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMaximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMaximum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMaximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "exclusiveMinimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"exclusiveMinimum\": ")
	if tmp, err := json.Marshal(strct.ExclusiveMinimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "format" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"format\": ")
	if tmp, err := json.Marshal(strct.Format); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "items" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"items\": ")
	if tmp, err := json.Marshal(strct.Items); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxItems\": ")
	if tmp, err := json.Marshal(strct.MaxItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxLength\": ")
	if tmp, err := json.Marshal(strct.MaxLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maxProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maxProperties\": ")
	if tmp, err := json.Marshal(strct.MaxProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "maximum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minItems\": ")
	if tmp, err := json.Marshal(strct.MinItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minLength" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minLength\": ")
	if tmp, err := json.Marshal(strct.MinLength); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minProperties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minProperties\": ")
	if tmp, err := json.Marshal(strct.MinProperties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "minimum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"minimum\": ")
	if tmp, err := json.Marshal(strct.Minimum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "multipleOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"multipleOf\": ")
	if tmp, err := json.Marshal(strct.MultipleOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "not" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"not\": ")
	if tmp, err := json.Marshal(strct.Not); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "nullable" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"nullable\": ")
	if tmp, err := json.Marshal(strct.Nullable); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "oneOf" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"oneOf\": ")
	if tmp, err := json.Marshal(strct.OneOf); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pattern" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"pattern\": ")
	if tmp, err := json.Marshal(strct.Pattern); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "properties" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "readOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"readOnly\": ")
	if tmp, err := json.Marshal(strct.ReadOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "required" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"required\": ")
	if tmp, err := json.Marshal(strct.Required); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uniqueItems" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"uniqueItems\": ")
	if tmp, err := json.Marshal(strct.UniqueItems); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "writeOnly" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"writeOnly\": ")
	if tmp, err := json.Marshal(strct.WriteOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "xml" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"xml\": ")
	if tmp, err := json.Marshal(strct.Xml); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Schema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "additionalProperties":
            if err := json.Unmarshal([]byte(v), &strct.AdditionalProperties); err != nil {
                return err
             }
        case "allOf":
            if err := json.Unmarshal([]byte(v), &strct.AllOf); err != nil {
                return err
             }
        case "anyOf":
            if err := json.Unmarshal([]byte(v), &strct.AnyOf); err != nil {
                return err
             }
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "deprecated":
            if err := json.Unmarshal([]byte(v), &strct.Deprecated); err != nil {
                return err
             }
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "discriminator":
            if err := json.Unmarshal([]byte(v), &strct.Discriminator); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        case "example":
            if err := json.Unmarshal([]byte(v), &strct.Example); err != nil {
                return err
             }
        case "exclusiveMaximum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMaximum); err != nil {
                return err
             }
        case "exclusiveMinimum":
            if err := json.Unmarshal([]byte(v), &strct.ExclusiveMinimum); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "format":
            if err := json.Unmarshal([]byte(v), &strct.Format); err != nil {
                return err
             }
        case "items":
            if err := json.Unmarshal([]byte(v), &strct.Items); err != nil {
                return err
             }
        case "maxItems":
            if err := json.Unmarshal([]byte(v), &strct.MaxItems); err != nil {
                return err
             }
        case "maxLength":
            if err := json.Unmarshal([]byte(v), &strct.MaxLength); err != nil {
                return err
             }
        case "maxProperties":
            if err := json.Unmarshal([]byte(v), &strct.MaxProperties); err != nil {
                return err
             }
        case "maximum":
            if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
                return err
             }
        case "minItems":
            if err := json.Unmarshal([]byte(v), &strct.MinItems); err != nil {
                return err
             }
        case "minLength":
            if err := json.Unmarshal([]byte(v), &strct.MinLength); err != nil {
                return err
             }
        case "minProperties":
            if err := json.Unmarshal([]byte(v), &strct.MinProperties); err != nil {
                return err
             }
        case "minimum":
            if err := json.Unmarshal([]byte(v), &strct.Minimum); err != nil {
                return err
             }
        case "multipleOf":
            if err := json.Unmarshal([]byte(v), &strct.MultipleOf); err != nil {
                return err
             }
        case "not":
            if err := json.Unmarshal([]byte(v), &strct.Not); err != nil {
                return err
             }
        case "nullable":
            if err := json.Unmarshal([]byte(v), &strct.Nullable); err != nil {
                return err
             }
        case "oneOf":
            if err := json.Unmarshal([]byte(v), &strct.OneOf); err != nil {
                return err
             }
        case "pattern":
            if err := json.Unmarshal([]byte(v), &strct.Pattern); err != nil {
                return err
             }
        case "properties":
            if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
                return err
             }
        case "readOnly":
            if err := json.Unmarshal([]byte(v), &strct.ReadOnly); err != nil {
                return err
             }
        case "required":
            if err := json.Unmarshal([]byte(v), &strct.Required); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "uniqueItems":
            if err := json.Unmarshal([]byte(v), &strct.UniqueItems); err != nil {
                return err
             }
        case "writeOnly":
            if err := json.Unmarshal([]byte(v), &strct.WriteOnly); err != nil {
                return err
             }
        case "xml":
            if err := json.Unmarshal([]byte(v), &strct.Xml); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Server) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "variables" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"variables\": ")
	if tmp, err := json.Marshal(strct.Variables); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Server) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        case "variables":
            if err := json.Unmarshal([]byte(v), &strct.Variables); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *ServerVariable) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Default" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "default" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "enum" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"enum\": ")
	if tmp, err := json.Marshal(strct.Enum); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ServerVariable) UnmarshalJSON(b []byte) error {
    defaultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
            defaultReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "enum":
            if err := json.Unmarshal([]byte(v), &strct.Enum); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if default (a required property) was received
    if !defaultReceived {
        return errors.New("\"default\" is required but was not present")
    }
    return nil
}

func (strct *Tag) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "externalDocs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"externalDocs\": ")
	if tmp, err := json.Marshal(strct.ExternalDocs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Tag) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "externalDocs":
            if err := json.Unmarshal([]byte(v), &strct.ExternalDocs); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *XML) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "attribute" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"attribute\": ")
	if tmp, err := json.Marshal(strct.Attribute); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "namespace" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"namespace\": ")
	if tmp, err := json.Marshal(strct.Namespace); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prefix" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"prefix\": ")
	if tmp, err := json.Marshal(strct.Prefix); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "wrapped" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"wrapped\": ")
	if tmp, err := json.Marshal(strct.Wrapped); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *XML) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "attribute":
            if err := json.Unmarshal([]byte(v), &strct.Attribute); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "namespace":
            if err := json.Unmarshal([]byte(v), &strct.Namespace); err != nil {
                return err
             }
        case "prefix":
            if err := json.Unmarshal([]byte(v), &strct.Prefix); err != nil {
                return err
             }
        case "wrapped":
            if err := json.Unmarshal([]byte(v), &strct.Wrapped); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
